% Work report
% Date: 2011-11-23
% Author: Yangfeng Ji @ Gatech
% Time-stamp: <yangfeng 09/25/2014 12:12:19>

\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{fancybox}
\usepackage{epsfig}
\usepackage{float}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{bm}

\newcommand{\codefile}[1]{\textbf{\textit{#1}}}
\newcommand{\codefunc}[1]{\textsf{#1}}
\newcommand{\codeclass}[1]{\textsc{#1}}

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\parskip 2.0mm
\topmargin  -2.0cm
\textwidth 16cm
\textheight 22.5cm
\topmargin -1.5cm
\oddsidemargin 0mm

\title{Shift-reduce based RST Parser Version 0.01}
\author{Yangfeng Ji}
\date{Sep. 25th, 2014}

\begin{document}
\maketitle
% ***************************************************
\section{RST based Discourse Processing}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{figures/tree-example.pdf}
  \caption{An example of RST tree.}
  \label{fig:tree-example}
\end{figure}

% ***************************************************
\section{Shift-reduce Parsing}
Shift-reduce parsing has been used in discourse parsing for more than 10 years \cite{Ji:14:RepLearn,Marcu:99:ACL,Sagae:05:SR}. As explained in \cite{Ji:14:RepLearn},  the way of choosing a specific parsing action can be viewed as a multi-class classification problem. In the classification based parsing framework, each specific parsing action corresponds one classification label. During parsing procedure, an multi-class classifier takes generated feature as input and outputs one specific parsing action. 


% ***************************************************
\section{Code}

% ---------------------------------------------------
\subsection{Demo}
Run code \codefile{main.py} for a demo

% ---------------------------------------------------
\subsection{Code Structure}
\begin{itemize}
\item \codefile{tree.py}: any operation about an RST tree is included in this module. For example
  \begin{itemize}
  \item Build general/binary RST tree from annotated file
  \item Binarize a general RST tree to the binary form (original RST trees in the RST treebank may not in the binary form)
  \item Generate bracketing sequence for evaluation
  \item Write an RST tree into file (not implemented yet)
  \item Generate Shift-reduce parsing action examples
  \item Get all EDUs from the RST tree
  \end{itemize}
\item \codefile{parser.py}: an implementation of the shift-reduce parsing algorithm, including following functions:
  \begin{itemize}
  \item Initialize parsing status given a sequence of texts
  \item Change the status according to a specific parsing action
  \item Get the status of stack/queue
  \item Check whether should stop parsing
  \end{itemize}
\item \codefile{model.py}: an parsing model module, where a trained parsing model could predict parsing actions. This module includes:
  \begin{itemize}
  \item Batch training on the data generated by the data module
  \item Predict parsing actions for a given feature set
  \item Save/load parsing model
  \end{itemize}
\item \codefile{feature}: an feature generator, which can generate features from current stack/queue status.
\item \codefile{data}: generate training data for offline training
\end{itemize}

% ---------------------------------------------------
\subsection{Data structure}
In RST parser, one important data structure for the RST parser is \codeclass{SpanNode}, which is defined in \codefile{datastructure.py}. It includes following properties:
\begin{itemize}
\item text: the text of this span
\item relation: discourse relation between this span and its sibling
\item eduspan: edu range in this span
\item nucspan: nucleus range in this span (not clear enough)
\item prop: property of this span with respect to its parent node. It only has two possible values: Nucleus or Satellite
\item lnode/rnode: left/right children node, which are also instances of class \codeclass{SpanNode}
\item pnode: parent node of this span, which is also an instance of class \codeclass{SpanNode}
\item nodelist: (only used for general RST tree)
\item form: the relation between this span and its sibling
\end{itemize}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{figures/circled-tree.pdf}
  \caption{The example tree for explaining the data structure \codeclass{SpanNode}.}
  \label{fig:circled}
\end{figure}

Taking the circled node in Figure \ref{fig:circled} as an example, it is a discourse span consisting of two child node: EDU 1 and EDU 2. For this node, the values of those properties are:
\begin{itemize}
\item text: the combination of text from EDU 1 and EDU 2
\item relation: Comparison
\item eduspan: (1,2)
\item nucspan: (2,2)
\item prop: Nucleus --- considering its sibling, which is a span consisting of EDU 3 and EDU 4, the circled node is a nucleus span while its sibling is a satellite span
\item lnode/rnode: EDU 1 / EDU 2
\item pnode: the root node
\item form: NS --- as the left child node of its parent, it is a nucleus span. Therefore, the form is NS (Nucleus-Satellite)
\end{itemize}

% ---------------------------------------------------
\subsection{Feature Generator}

The feature generator is defined in \codefile{feature.py}. The main purpose is to provide an unified feature generating process for training data and test data. The advantage of using an unified interface is to guarantee the consistency of the feature set.

Usually, for shift-reduce parsing, features are extract from the top two elements from the stack and the first element from the queue. Because those three elements are related to the decision making on parsing actions. 

In class \codeclass{FeatureGenerator}, there are four variables used within this class:
\begin{itemize}
\item \codefunc{span1}: the {\bf top first} element in the {\bf stack}, which is an instance of \codeclass{SpanNode}. If the stack is empty, it should be \codeclass{None}.
\item \codefunc{span2}: the {\bf top second} element in the {\bf stack}, which is an instance of \codeclass{SpanNode}. If the stack only has one element, it should be \codeclass{None}.
\item \codefunc{span3}: the {\bf first} element in the {\bf queue}. It is an instance of \codeclass{SpanNode} and also a single EDU. If the queue is empty, it should be \codeclass{None}.
\item \codefunc{doclen}: document length with respect to number of EDUs (As all document information could be inferred from the status of stack/queue, this variable could be removed in future).
\end{itemize}


one major function and three sub-functions:
\begin{itemize}
\item \codefunc{features()}: the major function to generate a set of features according the current status of stack and queue.
\item \codefunc{lexical\_features()}: extracting n-gram features or some other lexical features related to n-gram, for example, POS tags of n-gram.
\item \codefunc{structural\_features()}: structural information about one element (from either the top of stack or the head of queue) with respect to the entire document. For example, the distance from the beginning of document to the current span.
\item \codefunc{status\_features()}: information about the current status of stack/queue. For example, how many element in stack --- if there is only one element in stack, then definitely a shift action is required in the next parsing step.
\end{itemize}

As you may realize, there are tons of features could be useful for discourse parsing \cite{Feng:12:Text,Joty:13:Comb} and lots of them are missed from the current implementation. You are welcome to add any feature which you think are useful. 

% ---------------------------------------------------
\subsection{Evaluation}

% *******************END OF DOCUMENT*****************
\bibliographystyle{plain}
\bibliography{ref}
\end{document}

